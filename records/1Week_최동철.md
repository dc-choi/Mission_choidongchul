## 체크리스트

### 기능적 요구사항
1. 1단계: 종료
2. 2단계: 등록
3. 등록시 생성된 명언번호 노출
4. 등록될 때 마다 생성되는 명언번호 증가
5. 목록
6. 명언 삭제
7. 존재하지 않는 명언에 대한 예외처리
8. 명언 수정
9. 파일을 통한 영속성
10. data.json 빌드

### 비 기능적 요구사항
1. 소스코드 리팩토링
2. 요청을 처리하는 Req객체 도입
3. 간단한 MVC 프레임워크 구현하여 적용
4. 모든 기능에 대해 테스트 코드 적용

## 접근 방법

### 1단계: 종료
"종료"라는 명령어를 입력하게 되면, 프로그램이 종료되는 요구사항입니다.

"종료" 명령어가 있기 전까지는 프로그램이 종료되지 않아야 한다고 생각하였습니다.

그에 맞춰서 프로그램이 명령어 하나를 받으면 다음 명령어를 받을 수 있도록 무한루프로 처리하였습니다.

사용자의 입력을 받아야하므로, Scanner 객체에 대해 알아야 하며 사용자의 입력을 받을 수 있도록 처리하였습니다.

"종료" 명령어를 받게되면 프로그램이 종료되는 로직이 필요합니다. 그게 맞는 로직을 구성하였습니다.

### 2단계: 등록
"등록"이라는 명렁어를 입력하게 되면, 사용자의 입력을 받아 명언을 추가하는 요구사항입니다.

"등록" 명령어가 있기 전까지는 프로그램에 명언이 등록되면 안된다고 생각하였습니다.

마찬가지로 사용자의 입력을 받아야 하므로, Scanner 객체로 사용자의 입력을 받도록 처리하였습니다.

또한, 다음 입력을 처리하는 "\n"을 입력하기 전 까지 입력이 중지되지 않도록 하였습니다.

### 3단계: 등록시 생성된 명언번호 노출
"등록" 명령을 수행할 때 생성되는 명언 번호를 화면에 출력시키도록 하는 요구사항입니다.

"등록" 명령어가 입력되고 나서, 생성된 명언 번호를 화면에 출력시키도록 합니다.

명언 번호에 해당하는 부분은 Long 타입으로 반환하였습니다.

### 4단계: 등록될 때 마다 생성되는 명언번호 증가
"등록" 명령을 수행할 때 화면에 출력시키는 명언 번호를 하나씩 증가시키도록 하는 요구사항입니다.

"등록" 명령어가 입력되고 나서, 생성된 명언 번호를 하나씩 증가시키도록 합니다.

현재 있는 id의 최대값에 +1을 하여 명언번호가 증가되도록 하였습니다.

### 5단계: 목록
"목록" 명령을 수행할 때 화면에 등록했던 명언이 출력되도록 하는 요구사항입니다.

"목록" 명령어가 입력되고 나서, 화면에 등록한 명언이 출력되도록 하였습니다.

List의 forEach문을 사용하였고, 안에는 람다를 사용하여 코드 가독성을 좋게 하였습니다.

### 6, 7단계: 명언 삭제 및 존재하지 않는 명언에 대한 예외처리
"삭제" 명령을 수행할 때 고유의 id를 가지는 명언이 삭제되도록 하는 요구사항입니다.

"삭제" 명령어가 입력되고 나서, id에 해당하는 명언 객체가 삭제되도록 하였습니다.

만약 id에 해당하는 명언에 대해서 찾을 수 없다면 그에 맞는 예외처리를 하였습니다.

### 8단계: 명언 수정
"수정" 명령을 수행할 때 고유의 id를 가지는 명언이 수정되도록 하는 요구사항입니다.

"수정" 명령어가 입력되고 나서, id에 해당하는 명언 객체가 수정되도록 하였습니다.

삭제와 마찬가지로 만약 id에 해당하는 명언에 대해서 찾을 수 없다면 그에 맞는 예외처리를 하였습니다.

### 9, 10단계: 파일을 영속성 및 data.json 빌드
"종료" 명령어를 입력하는 경우 파일이 저장되도록 하는 명령어와 "빌드" 명령어를 입력하는 경우 data.json이 빌드 되는 요구사항입니다.

"종료" 명령어가 입력되면 기존의 있는 파일들이 전부 저장이 되도록 추가하였습니다.

JSON을 빌드하는 경우 Jackson 라이브러리를 사용하여 JSON으로 빌드하였습니다.

### 비 기능적 요구사항: 리팩터링
1. 간단한 MVC 프레임워크 구현하여 적용하면서 전체적인 코드의 가독성을 높였습니다.
2. 요청을 처리하는 Req객체 도입을 하여 요청에 처리를 따로 분류할 수 있도록 하였습니다.
3. 모든 기능에 대해 테스트 코드 적용하여 기능적 요구사항에 대한 누락이 없는지 확인하였습니다.

## 특이사항
특이사항이 있던 작업 내역에 대해서 말씀드리도록 하겠습니다.

### 4단계
mysql의 auto_increment 기능과 비슷하도록 구현하였습니다.

배열의 사이즈로 계산하는 것이 아닌, 현재 가지고있는 배열의 최대 id 크기를 사용해서 최대값을 구현하였습니다.

### 9단계
파일을 통해 영속성을 가지게 되도록 하였습니다.

영속성을 가지기 위해서는 각 명령어마다 파일을 저장할 필요가 있었습니다.

명언 배열 객체에 직접적으로 영향을 주는 CUD 작업의 경우 바로바로 파일에 저장되도록 처리하였습니다.

### 요청을 처리하는 Req객체 도입
실제 Servlet에서 처리되는 방법에 따라 요청을 처리하고 parse하는 메서드를 제작하였습니다.

getParameter() 메서드를 최대한 비슷하게 구현하려고 하였습니다.

### 간단한 MVC 프레임워크 구현
Spring의 거대한 구조를 전부 따라할 수 는 없지만, Spring MVC의 흐름에 맞춰서 코드를 작성하였습니다.

Spring MVC 오픈 소스를 확인하면서 구현을 진행하였습니다.

### 모든 기능에 대해 테스트 코드 적용
테스트 코드를 작성하면서 실제 환경과 테스트 환경에 대한 분리가 굉장히 필요했습니다.

특히 파일쪽을 테스트하면서 mock에 대해서 고민하였습니다.

mock 프레임워크를 사용할 수 없는 환경이기도 했고 mock을 사용하게 된다면 모든 코드에 대한 mock 처리가 필요하여 mock은 사용하지 않았습니다.

대신 테스트 환경을 철저하게 분리하도록 코드를 다시 작성하였습니다.

Spring에 대해서 얼른 학습하게 된다면 지금 부분을 더욱 더 깔끔하게 작성할 수 있을 것으로 예상합니다.